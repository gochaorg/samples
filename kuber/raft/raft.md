Кластерное приложение
==================================

```mermaid
flowchart

client-a --> cluster
client-b --> cluster
subgraph cluster
  node-a
  node-b
  node-c

  node-a --- node-b --- node-c
end
```

Выбор лидера RAFT
=========================

Узел кластера может быть в одном из 3 состояний:

- **Leader** (лидер) - 
  обрабатывает все клиентские запросы, является source of truth всех данных в логе, поддерживает лог фоловеров.
- **Follower** (фоловер)
  пассивный сервер, который только «слушает» новые записи в лог от лидера и редиректит все входящие запросы от клиентов на лидера. По сути, является hot-standby репликой лидера.
- **Candidate** (кандидат)
  специальное состояние сервера, возможное только во время выбора нового лидера.

Во время нормальной работы в кластере только один сервер является лидером, все остальные – его фоловеры.

**Граф переходов состояния**

```mermaid
stateDiagram-v2
[*] -->  Follower
Follower --> Candidate : Если не получает сообщения от Leader
Candidate --> Follower : Получил сообщение от Leader
Candidate --> Leader : Когда получил большиство голосов
Leader --> Follower : Когда был выбран новый лидер большиством
```

**Инициализация выбора лидера**

```mermaid
sequenceDiagram

participant na as Node A
participant nb as Node B
participant nc as Node C

rect rgb(191,223,255)
  note right of na: A - В состоянии Follower <br> R = 1
  note right of nb: B - В состоянии Leader <br> R = 1
  note right of nc: C - В состоянии Follower <br> R = 1
  %% note over na,nb: aa

  activate nb
  note right of nb: Рассылка hearbeat, спустя N секунд

  nb ->>+ na: hearbeat
  nb ->>+ nc: hearbeat
  na ->>- nb: ok
  nc ->>- nb: ok

  deactivate nb
end

note right of na: Начало выборов

nb --x na : heartbeat не дошел

loop пока кто-нибудь не наберет большинство голосов
  na ->> na : Задержка rnd( 100 .. 300 ms )

  activate na
  note right of na: Переход в Candidate
  deactivate na

  na ->> nb : отправка своего голоса всем в раунде (R+1)
  na ->> nc : отправка своего голоса всем в раунде (R+1)
  nb ->> na : yes/no - голос за/против в раунде R+1
  nc ->> na : yes/no - голос за/против в раунде R+1
end

rect rgb(191,223,255)
  note right of na: Переход в Leader
  na ->> nb : Объявления себя лидером, разослать всем что R+1 я лидер
  na ->> nc : Объявления себя лидером, разослать всем что R+1 я лидер
end
```

Коммуникация
---------------------------

- Каждый сервер отслеживает номер своего текущего срока(раунда).
- Сервер включает номер своего срока в каждое отправляемое сообщение.
- Если сервер получает сообщение с меньшим номером срока, чем его собственный, то он игнорирует это сообщение.
- Если сервер получает сообщение с бо́льшим номером срока, чем его собственный, то он обновляет свой номер срока, чтобы тот соответствовал полученному.
- Если кандидат или лидер получает сообщение с бо́льшим номером срока, чем его собственный, то он понимает, что другие сервера уже инициировали новый срок, а его срок более неактуален. Поэтому он переходит из текущего состояния в состояние «фоловер» вдобавок к обновлению своего номера.

**обработка номера раунда**
```mermaid
stateDiagram-v2
Candidate: Candidate / Leader

[*] --> Follower : initial
[*] --> Candidate
[*] --> Leader

state Follower {
  read_f: read incoming
  state check_f <<choice>>
  ignore_f: ignore<br>message
  impl_f: run impl.
  update_f: update cur.round = msg.round

  [*] --> read_f
  read_f --> check_f
  check_f --> ignore_f : msg.round < cur.round
  check_f --> impl_f : msg.round == cur.round
  check_f --> update_f : msg.round > cur.round
  update_f --> read_f
  impl_f --> read_f
  ignore_f --> read_f
  read_f --> [*] : No hearbeat <br> go Candidate
}

Follower --> Candidate
Candidate --> Follower
Candidate --> Leader

state Candidate {
  state check_c <<choice>>
  state c_vote_c <<choice>>

  [*] --> vote_c

  vote_c --> read_c
  read_c --> check_c

  check_c --> ignore_c : msg.round < cur.round
  ignore_c --> vote_c

  check_c --> impl_c: msg.round == cur.round
  impl_c --> vote_c

  check_c --> switch_c: msg.round > cur.round
  switch_c --> [*] : go Follower

  impl_c --> c_vote_c

  c_vote_c --> [*] : win <br> go Leader
  c_vote_c --> [*] : loose <br> go Follower
  c_vote_c --> vote_c : split votes
}
```


Коммуникация серверов. Серверы в Raft взаимодействуют посредством обмена запросами и ответами. Базовый алгоритм использует всего-навсего два вида вызовов:

- **RequestVote** используется кандидатами во время выборов. Запрос содержит номер срока кандидата и метаданные о логе кандидата, более подробно рассмотренные далее. Ответ содержит номер срока отвечающего сервера и значение «true», если сервер голосует за кандидата; «false», если сервер голосует против кандидата.
- **AppendEntries** используется лидером для репликации лога, а также для механизма heartbeat. Запрос содержит номер срока лидера, коллекцию записей, которые нужно добавить в лог (или пустую коллекцию в случае heartbeat), некоторые метаданные о логе лидера, также подробнее рассмотренные далее. Ответ содержит номер срока фоловера и значение «true», если фоловер успешно добавил записи в свой лог; «false», если добавить записи в лог не удалось.

Для инициации выборов фоловер инкрементит свой номер срока, переходит в состояние «кандидат», голосует сам за себя и затем рассылает запрос «RequestVote» всем остальным серверам. После этого кандидат ждёт одного из трёх событий:

- **Кандидат получает большинство голосов (включая свой) и побеждает в выборах**. Каждый сервер голосует в каждом сроке лишь единожды, за первого достучавшегося кандидата (с некоторым исключением, рассмотренным далее), поэтому набрать в конкретном сроке большинство голосов может только один кандидат. Победивший сервер становится лидером, начинает рассылать heartbeat и обслуживать запросы клиентов к кластеру.
- **Кандидат получает сообщение от уже действующего лидера текущего срока или от любого сервера более старшего срока**. В этом случае кандидат понимает, что выборы, в которых он участвует, уже не актуальны. Ему не остаётся ничего, кроме как признать нового лидера/новый срок и перейти в состояние фоловер.
- **Кандидат не получает за некоторый таймаут большинство голосов**. Такое может произойти в случае, когда несколько фоловеров становятся кандидатами, и голоса разделяются среди них так, что ни один не получает большинства. В этом случае срок заканчивается без лидера, а кандидат сразу же начинает новые выборы на следующий срок

Реплицируем логи
===========================

Когда лидер выбран, на него ложится ответственность за управление распределённым логом. Лидер принимает от клиентов запросы, содержащие некоторые команды. Лидер кладёт в свой лог новую запись, содержащую команду, а затем отсылает «AppendEntries» всем фоловерам, для того чтобы отреплицировать запись с новой записью.

Когда запись будет успешно разреплицирована на большинстве серверов, лидер начинает считать запись закоммиченой и отвечает клиенту. Лидер следит за тем, какая запись является последней. Он отправляет номер этой записи в AppendEntries (включая heartbeat), чтобы фоловеры могли закоммитить запись у себя.

В случае, если лидер не может достучаться до некоторых фоловеров, он будет ретраить AppendEntries до бесконечности.

